# 简介

### Damo是什么

Damo是一套基于状态管理机制构建用户界面的框架。采用自底向上增量开发的设计。Damo 的核心库关注视图结构和视图状态。同时Damo借助一些前端优秀设计方案，帮你在开发前端应用时节省下大量时间。

### 起步

> 官方指南假设你已有 HTML、CSS 和 JavaScript 中级前端知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来！

你还需要掌握React的基础知识，为了方便开发，先按照\[快速上手\]\(chapter1.html\)篇章启动应用，开始我们的React的学习教程。

编辑`app/app.jsx`文件，重新写入我们第一个“Hello World”的React组件

```
import React, {Component, PropTypes} from 'react';
import ReactDOM from 'react-dom';

const FirstComponent = (<h1>Hello World!</h1>);

ReactDOM.render(<FirstComponent/>, document.body);
```

刷新浏览器看到最新的效果了，我们可以猜到：

1. `FirstComponent`是一个组件（React组件），并且由\(\)括号包围的HTML标签及内容可以得到一个React组件。
2. `ReactDOM.render`把React组件的真实结构插入到页面body中。
3. 执行一个React组件，需要把组件当做为HTML标签来调用。比如`<FirstComponent/>`;一个React组件的调用可以新的React组件。比如`const SecondComponent = (<FirstComponent/>)`

React组件所在的文件头部，一般来说都需要引入2个模块（避免带来不必要的麻烦）

```
import React, {Component, PropTypes} from 'react';
import ReactDOM from 'react-dom';

ReactDOM.render(<h1>Hello World!</h1>, document.body);
```

* `FirstComponent`组件的“Hello World!”文本需要换成插值变量，如何变？

```
const message = 'Hello World!';
const FirstComponent = (<h1>{message}</h1>);
```

最终页面渲染的结果是一样的。可是变量和组件是分开的，如果可以放到一个闭包函数中，这样组件会更干净。

```
const FirstComponent = function(props){
    const message = 'Hello World!';
    return (<h1>{message}</h1>);
}
```

* FirstComponent组件的插值变量从组件使用的时候获取

```
const FirstComponent = function(props){
    return (<h1>{props.message}</h1>);
}
ReactDOM.render(<FirstComponent message="Hello World!"/>, document.body);
```

到这一步需要掌握几点新知识：

1. 组件函数的props参数，是React组件在调用时传入的所有属性的集合。
2. React组件调用时传入属性值，需要通过组件作为标签编码时，标签上的属性，key=value形式，更进一步，value可以为字符串，也可以为其他任意JS类型的数据，作为其他类型数据时，需要通过{}大括号来包括。
3. 在{}大括号包含的语句可以是JS表达式，也可以是React组件的调用。

4. FirstComponent组件的标准代码，JSX模板放在render方法下

```
class FirstComponent extends Component{
    render(){
        return (<h1>{this.props.message}</h1>);
    }
}
```

下面将更详细介绍React组件。

### 模板即组件

在HelloWorld的例子里`<h1>Hello World!</h1>` ，这是React的模板，它不是字符串（因为不需要用双引号包含），也不是HTML标签（使用上却基本和HTML无异），模板我们称之为JSX，每一段合法JSXshi一个React元素Element，同时也叫一个React组件。

模板要应用到HTML文档中，通过`ReactDOM.render(<ReactElement/>, DOM)` 把ReactElement的执行结果插入到指定的DOM元素下。

[WebComponent规范](https://www.w3.org/wiki/WebComponents/)定义了Web开发的新标准，开发者可以创建自定义的HTML元素，并且拥有和原生的内置标签一样的优点：属性、内容、样式和事件。WebComponent开发的组件是跟框架无关、组件完全独立（就好比H5标签Video，拥有视频播放、暂定等功能，在使用时只是一个HTML的Video标签），可供其他开发者使用。

> 如果把WebComponent的HTML结构叫做模板，那WebComponent就是组件，同时WebComponent又是自定义的HTML标签，模板即组件。
>
> 从这个角度出发，React就是服务端的WebComponent, JSX模板即时React组件，最终借助React的核心API解释为JS代码执行。

* 那为何不用Web Component开发规范，去掉一切框架。

这取决于浏览器对ECMAscript和DOM级别的解释执行能力，只有少数的浏览器版本支持原生Web Component API，另外应用开发并不只是开发组件这么简单，包括组件通信，组件和服务端数据通信等各类问题。

谷歌的[Polymer框架](https://www.polymer-project.org/)正是基于WebComponent规范并且解决浏览器兼容的polyfill框架，感兴趣可以去了解下。

* 使用了Web Component开发后，React成为过去式？

Web Component定义了Web组件的开发规范，组件内部的HTML结构、交互，甚至更复杂的嵌套仍需要解决。而React非常适合解决组件内部复杂逻辑的问题，更理想的方式Web Component API来定义自定义HTML标签，内部通过React创建组件真实内容，最后一步通过`ReactDOM.render`把React组件挂载进来。

### 一个完整的组件

我们将展示一个完整的TodoList组件来完成组件渲染、组件事件 和 子组件之间通信。

```
import React, {Component, PropTypes} from 'react';
import ReactDOM from 'react-dom';

// 定义选项组件
class TodoItem extends Component{
    static propTypes = {
        message: PropTypes.string
    }
    render(){
        return (<li>{message}</li>);
    }
}
// 定义列表组件
class TodoList extends Component{
    static propTypes = {
        data: PropTypes.array
    }
    
    render(){
        return (<ul>
         {
             this.props.data.map(function(item){
                 return (<TodoItem key={item.id} message={item.text}/>);
             })
         }
        </ul>)
    }
}
// 外部数据，可以是静态数据，也可以是接口获取的数据
const outsideData = [
    { id: 1, text: '刷牙' },
    { id: 2, text: '洗脸' },
    { id: 3, text: '吃早饭' }
]
// 组件挂在到指定DOM
ReactDOM.render(<TodoList>, document.body);
```

代码展示了父子组件嵌套关系的使用，包括：

1. 组件有静态属性`propTypes` 用来声明输入组件的属性未指定类型，帮助浏览器执行发现组件使用的错误。

### 应用构建



